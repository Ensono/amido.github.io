"use strict";(self.webpackChunkstacks=self.webpackChunkstacks||[]).push([[9266,4422],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return g}});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(t),m=o,g=u["".concat(l,".").concat(m)]||u[m]||d[m]||r;return t?a.createElement(g,i(i({ref:n},c),{},{components:t})):a.createElement(g,i({ref:n},c))}));function g(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,i=new Array(r);i[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[u]="string"==typeof e?e:o,i[1]=s;for(var p=2;p<r;p++)i[p]=t[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},3602:function(e,n,t){t.r(n);var a=t(7294);n.default=function(e){var n=e.next,t=e.prev;return a.useEffect((function(){if(n){var e=document.querySelector("div.pagination-nav__item.pagination-nav__item--next>a");e&&e.style&&(e.style.display="none")}if(t){var a=document.querySelector("div.pagination-nav__item>a");a&&a.style&&(a.style.display="none")}})),a.createElement("div",null)}},4391:function(e,n,t){t.r(n),t.d(n,{contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return c}});var a=t(7462),o=t(3366),r=(t(7294),t(3905)),i=(t(3602),["components"]),s={id:"java_swagger_annotations",title:"Reducing Swagger Annotation Overload",sidebar_label:"Reducing Swagger Annotation Overload",description:"Reducing Swagger Annotation Overload",keywords:["development","java","backend","server-side"]},l=void 0,p={unversionedId:"developer/java/patterns/java_swagger_annotations",id:"developer/java/patterns/java_swagger_annotations",isDocsHomePage:!1,title:"Reducing Swagger Annotation Overload",description:"Reducing Swagger Annotation Overload",source:"@site/docs/developer/java/patterns/java_swagger_annotations.md",sourceDirName:"developer/java/patterns",slug:"/developer/java/patterns/java_swagger_annotations",permalink:"/docs/developer/java/patterns/java_swagger_annotations",tags:[],version:"current",frontMatter:{id:"java_swagger_annotations",title:"Reducing Swagger Annotation Overload",sidebar_label:"Reducing Swagger Annotation Overload",description:"Reducing Swagger Annotation Overload",keywords:["development","java","backend","server-side"]},sidebar:"docs",previous:{title:"Reducing Bean Mapping Boilerplate",permalink:"/docs/developer/java/patterns/java_mapstruct_mapping"},next:{title:"Introduction",permalink:"/docs/workloads/workloads"}},c=[{value:"Context",id:"context",children:[],level:2},{value:"Solution",id:"solution",children:[],level:2},{value:"Implementation Examples",id:"implementation-examples",children:[],level:2}],u={toc:c},d="wrapper";function m(e){var n=e.components,t=(0,o.Z)(e,i);return(0,r.kt)(d,(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"context"},"Context"),(0,r.kt)("p",null,"The API documentation is an essential part of building REST APIs to make the services available to all audience.\nThis documentation should help consumers of the service know which all services are available and its fine details.\nAlso, there should be some simple way to test if the service is up. "),(0,r.kt)("p",null,"SpringDoc simplifies the generation and maintenance of API docs based on the OpenAPI 3 specification for the spring boot applications.\nThe exposed services are bound to change and the documentation needs to be updated as the services change.\nIf this is done manually, then it will become a complex process, and it will be prone to error, especially as the number of REST services increase.\nThis is where swagger helps to automate this documentation process and the consumers of this API would see the output of all of this in the swagger UI (for example, the Swagger API Doc Endpoint at ",(0,r.kt)("em",{parentName:"p"},"/swagger/index.html"),")."),(0,r.kt)("p",null,"The proliferation of Swagger annotation's means that there is a lot of duplicated APIResponse annotations that bloat the code and make it difficult to maintain and read."),(0,r.kt)("h2",{id:"solution"},"Solution"),(0,r.kt)("p",null,'To avoid the code duplication around swagger annotations, we have opted to use our own @interface Java annotation to "carry" these annotations and make them a reusable unit\nwhich will minimise the duplicated Swagger annotations from controller methods.'),(0,r.kt)("h2",{id:"implementation-examples"},"Implementation Examples"),(0,r.kt)("p",null,"We have defined custom java annotations per CRUD operation to be used by the controller classes. This will promote re-usability of the\nswagger annotations rather than duplicating the code across multiple controller classes."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example of java custom annotation:")),(0,r.kt)("p",null,"In the below example we have:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Added multiple Swagger REST response annotations to our own annotation "),(0,r.kt)("li",{parentName:"ul"},"Added the Security Requirement annotation")),(0,r.kt)("p",null,"This is so that we have a single annotation that a developer can use to easily apply all of these Swagger repetitive annotations\nacross multiple classes using just a single annotation per class, therefore fixing the problem being addressed - annotation bloat."),(0,r.kt)("p",null,"In the below example, we are creating ReadAPIResponses annotation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@ApiResponses({@ApiResponse(\n    responseCode = "404",\n    description = "Resource not found",\n    content = {@Content(\n    mediaType = "application/json",\n    schema = @Schema(\n    implementation = ErrorResponse.class))}), \n  @ApiResponse(\n    responseCode = "400",\n    description = "Bad Request",\n    content = {@Content(\n    mediaType = "application/json",\n    schema = @Schema(\n    implementation = ErrorResponse.class))}\n  )})\n@SecurityRequirement(name = "bearerAuth")\npublic @interface ReadAPIResponses {}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Using the custom Annotation @ReadAPIResponses:")),(0,r.kt)("p",null,"In the below code example, java custom annotation @ReadAPIResponses has been used."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'@RestController\npublic class MenuController {\n\n  @GetMapping(value = "/{id}")\n  @Operation(tags = "Menu", summary = "Get a menu", description = "By passing the menu id, ...")\n  @ReadAPIResponses\n  ResponseEntity<MenuDTO> getMenu(\n    @PathVariable(name = "id") UUID id,\n    @Parameter(hidden = true) @RequestAttribute("CorrelationId") String correlationId) {\n      \n        // Code here\n      \n  }\n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Overriding the custom annotations:")),(0,r.kt)("p",null,"We can override our new custom annotation entries by placing the annotation ",(0,r.kt)("strong",{parentName:"p"},"before the new custom annotation"),".\nIn the below example, @ApiResponse entry will ",(0,r.kt)("strong",{parentName:"p"},"override")," the 200 response code in @ReadAPIResponses custom annotation as the @ApiResponse comes ",(0,r.kt)("strong",{parentName:"p"},"before"),"\n@ReadAPIResponses. We just have to make that the annotations are placed in the right order."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'@RestController\npublic class MenuController {\n\n  @GetMapping(value = "/{id}")\n  @Operation(tags = "Menu", summary = "Get a menu", description = "By passing the menu id, ...")\n  @ApiResponse(\n      responseCode = "200",\n      description = "Menu",\n      content =\n      @Content(\n          mediaType = MediaType.APPLICATION_JSON_VALUE,\n          schema = @Schema(implementation = MenuDTO.class)))\n  @ReadAPIResponses\n  ResponseEntity<MenuDTO> getMenu(\n      @PathVariable(name = "id") UUID id,\n      @Parameter(hidden = true) @RequestAttribute("CorrelationId") String correlationId) {\n      \n        // Code here\n             \n  }\n}\n')))}m.isMDXComponent=!0}}]);