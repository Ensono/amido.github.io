"use strict";(self.webpackChunkstacks=self.webpackChunkstacks||[]).push([[6232],{3905:function(e,t,a){a.d(t,{Zo:function(){return u},kt:function(){return m}});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),d=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},u=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},g=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=d(a),g=i,m=p["".concat(s,".").concat(g)]||p[g]||c[g]||r;return a?n.createElement(m,o(o({ref:t},u),{},{components:a})):n.createElement(m,o({ref:t},u))}));function m(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=g;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:i,o[1]=l;for(var d=2;d<r;d++)o[d]=a[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}g.displayName="MDXCreateElement"},6869:function(e,t,a){a.r(t),a.d(t,{contentTitle:function(){return s},default:function(){return g},frontMatter:function(){return l},metadata:function(){return d},toc:function(){return u}});var n=a(7462),i=a(3366),r=(a(7294),a(3905)),o=["components"],l={id:"ingest_data_azure",title:"Data Ingest Workloads",sidebar_label:"Data Ingest Workloads",hide_title:!1,hide_table_of_contents:!1,description:"Data Ingest Workloads",keywords:["ingest","adf","etl"]},s=void 0,d={unversionedId:"workloads/azure/data/etl_pipelines/ingest_data_azure",id:"workloads/azure/data/etl_pipelines/ingest_data_azure",isDocsHomePage:!1,title:"Data Ingest Workloads",description:"Data Ingest Workloads",source:"@site/docs/workloads/azure/data/etl_pipelines/ingest_data_azure.md",sourceDirName:"workloads/azure/data/etl_pipelines",slug:"/workloads/azure/data/etl_pipelines/ingest_data_azure",permalink:"/docs/workloads/azure/data/etl_pipelines/ingest_data_azure",tags:[],version:"current",frontMatter:{id:"ingest_data_azure",title:"Data Ingest Workloads",sidebar_label:"Data Ingest Workloads",hide_title:!1,hide_table_of_contents:!1,description:"Data Ingest Workloads",keywords:["ingest","adf","etl"]},sidebar:"docs",previous:{title:"ETL Overview",permalink:"/docs/workloads/azure/data/etl_pipelines/etl_intro_data_azure"},next:{title:"Data Processing Workloads",permalink:"/docs/workloads/azure/data/etl_pipelines/data_processing"}},u=[{value:"Pipeline overview",id:"pipeline-overview",children:[],level:2},{value:"Configuration",id:"configuration",children:[{value:"Query generation",id:"query-generation",children:[{value:"Full load",id:"full-load",children:[],level:4},{value:"Delta load",id:"delta-load",children:[],level:4}],level:3}],level:2},{value:"Data Factory pipeline design",id:"data-factory-pipeline-design",children:[{value:"Data Factory triggers",id:"data-factory-triggers",children:[],level:3}],level:2}],p={toc:u},c="wrapper";function g(e){var t=e.components,l=(0,i.Z)(e,o);return(0,r.kt)(c,(0,n.Z)({},p,l,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Data ingest workloads in Stacks are jobs which:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Connect to an external data source"),(0,r.kt)("li",{parentName:"ol"},"Land the data in the Bronze (raw) layer of the data lake")),(0,r.kt)("p",null,"Data ingest workloads utilise ",(0,r.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/azure/data-factory/connector-overview"},"Azure Data Factory's inbuilt connectors")," and ",(0,r.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/azure/data-factory/copy-activity-overview"},"Copy activity"),", to give the ability to easily ingest data from a wide range of data sources. The ingest process is designed around reusable, metadata-driven pipelines. This means once\nan initial data pipeline is created for a given data source, additional entities from the same data source can be added or modified just by updating a configuration file."),(0,r.kt)("p",null,"Data ingest workloads may also optionally include a ",(0,r.kt)("a",{parentName:"p",href:"/docs/workloads/azure/data/etl_pipelines/data_quality_azure"},"Data Quality validations")," step, executed in Databricks."),(0,r.kt)("p",null,"The solution contains a the following example data ingest workloads:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/ensono/stacks-azure-data/tree/main/de_workloads/ingest/Ingest_AzureSql_Example"},"Ingest_AzureSql_Example"),": Ingests data from the ",(0,r.kt)("a",{parentName:"li",href:"/docs/workloads/azure/data/getting_started/example_data_source"},"example Azure SQL source")," and lands data into the data lake Bronze layer.")),(0,r.kt)("h2",{id:"pipeline-overview"},"Pipeline overview"),(0,r.kt)("p",null,"The diagram below gives an overview of the ingestion pipeline design."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"ADF_IngestPipelineDesign.png",src:a(6050).Z})),(0,r.kt)("h2",{id:"configuration"},"Configuration"),(0,r.kt)("p",null,"The configuration files for the workload are\nstored in the pipeline's ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ensono/stacks-azure-data/tree/main/de_workloads/ingest/Ingest_AzureSql_Example/config"},"config")," directory."),(0,r.kt)("p",null,"JSON format is used for the configuration files. Our blueprint includes a sample configuration definition for the data ingestion sources\n(",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ensono/stacks-azure-data/blob/main/de_workloads/ingest/Ingest_AzureSql_Example/config/ingest_sources/Ingest_AzureSql_Example.json"},"Ingest_AzureSql_Example.json"),")\nand its schema (",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ensono/stacks-azure-data/blob/main/de_workloads/ingest/Ingest_AzureSql_Example/config/schema/ingest_config_schema.json"},"ingest_config_schema.json"),")."),(0,r.kt)("p",null,"The sample ingest pipeline is based around an Azure SQL data source, however the approach used should be adaptable for most other data source types with minimal modifications. Different data data source types would be expected to have the same JSON keys, except for under ",(0,r.kt)("inlineCode",{parentName:"p"},"ingest_entities"),",\nwhere different keys will be required dependent on the data source type."),(0,r.kt)("p",null,"See the descriptions of the example JSON config file below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'{\n    "data_source_name": "example_azuresql_1",  # Identifier of the data source - must be unique\n    "data_source_type": "azure_sql",           # Data source type\n    "enabled": true,                           # Boolean flag to enable / disable the data source from being ingested\n    "ingest_entities": [                       # Array of entities to be ingested from the source\n        {\n            "version": 1,                      # Version number - increment this if the entity\'s schema changes\n            "display_name": "SalesLT.Product", # Name to identify the entity - must be unique per data source\n            "enabled": true,                   # Boolean flag to enable / disable the entity from being ingested\n            "schema": "SalesLT",               # (SQL sources only) Database schema\n            "table": "Product",                # (SQL sources only) Database table\n            "columns": "*",                    # (SQL sources only) Columns to select. May also contain SQL-expressions for columns.\n            "load_type": "delta",              # (SQL sources only) Full or delta load. If delta load selected, then also include the following keys\n            "delta_date_column": "ModifiedDate",  # (SQL sources only, delta load) Date column to use for filtering the date range. May also contain SQL-expressions for columns.\n            "delta_upsert_key": "SalesOrderID"    # (SQL sources only, delta load) Primary key for determining updated columns in a delta load. May also contain SQL-expressions for columns.\n        }\n    ]\n}\n')),(0,r.kt)("p",null,"These configuration files will be referenced each time an ingestion pipeline\nis triggered in Data Factory, and all entities will be ingested. To disable a particular ingest\nsource or entity without removing it, you can set ",(0,r.kt)("inlineCode",{parentName:"p"},'"enabled": false')," \u2013 these will be ignored by\nthe Data Factory pipeline."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/ensono/stacks-azure-data/tree/main/de_workloads/ingest/Ingest_AzureSql_Example/tests/unit"},"Unit tests"),"\nare provided to ensure the config files remain valid against the schema."),(0,r.kt)("h3",{id:"query-generation"},"Query generation"),(0,r.kt)("p",null,"Values from the config will be used to generate the logic for extracting from the data source. For an Azure SQL data source, an SQL query would be generated for each ingest_entity as follows:"),(0,r.kt)("h4",{id:"full-load"},"Full load"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT {columns}\nFROM {schema}.{table}\n;\n")),(0,r.kt)("h4",{id:"delta-load"},"Delta load"),(0,r.kt)("p",null,"Note: ",(0,r.kt)("inlineCode",{parentName:"p"},"run_window_start_date")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"run_window_end_date")," are determined by the values passed at runtime, e.g. by the ",(0,r.kt)("a",{parentName:"p",href:"#data-factory-triggers"},"tumbling window trigger"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT {columns}\nFROM {schema}.{table}\nWHERE {delta_date_column} >= {run_window_start_date}\n  AND {delta_date_column} < {run_window_end_date}\n;\n")),(0,r.kt)("h2",{id:"data-factory-pipeline-design"},"Data Factory pipeline design"),(0,r.kt)("p",null,"The provided sample pipelines give an example of a data ingest process from source to the data lake.\nThe pipelines folder is structured as follows:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"ADF_IngestPipelinesList.png",src:a(2359).Z})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Ingest")," contains ingest pipelines specific to the given data source. The naming convention for\nthese pipelines is ",(0,r.kt)("inlineCode",{parentName:"li"},"Ingest_{SourceType}_{SourceName}"),". These are the parent pipelines that would be\ntriggered on a recurring basis to ingest from a data source. All pipelines have their equivalents\nthat include Data Quality validations. Depending on your particular needs, you can deploy each of\nthe pipelines with or without this additional Data Quality step. ",(0,r.kt)("a",{parentName:"li",href:"/docs/workloads/azure/data/etl_pipelines/data_quality_azure"},"Further information on Data Quality"),"."),(0,r.kt)("li",{parentName:"ul"},"The pipelines within ",(0,r.kt)("inlineCode",{parentName:"li"},"Utilities")," are reusable and referenced by other pipelines. They are not\nmeant to be triggered independently. These are defined within the ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/ensono/stacks-azure-data/tree/main/de_workloads/shared_resources"},"shared_resources")," for the project.")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Ingest_AzureSql_Example")," pipeline consists of the following steps:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"ADF_Ingest_AzureSql_Example.png",src:a(9392).Z})),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"Get_Ingest_Config"),": Calls the utility pipeline, passing the data source name as a parameter.\nThis will return the configuration required for the given data source."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"For_Each_Ingest_Entity"),": Loop through each ingest entity performing the following steps:",(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"Generate_Ingest_Query"),": Generates a SQL query to extract the data from a required time range,\naccording to the provided configuration. Depending on the load type, one of the two scenarios\nbelow will be applied:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Full extraction loads all available data for a given set of columns,"),(0,r.kt)("li",{parentName:"ul"},"Delta queries contain a ",(0,r.kt)("inlineCode",{parentName:"li"},"WHERE")," clause to restrict the date range loaded."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"SQL_to_ADLS"),": Execute the SQL query against the data source, and copy the results to the\nAzure Data Lake storage landing container under the appropriate path (data is validated using\nADF's built-in data validation capability).")))),(0,r.kt)("p",null,"The following picture shows the two possibilities of full vs delta extraction in ",(0,r.kt)("inlineCode",{parentName:"p"},"Generate_Ingest_Query"),":"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"ADF_IngestGenerateIngestQuery.png",src:a(5047).Z})),(0,r.kt)("h3",{id:"data-factory-triggers"},"Data Factory triggers"),(0,r.kt)("p",null,"An example Data Factory pipeline trigger is provided and associated to the ingest pipeline. Triggers can be viewed in the Data Factory UI through Manage > Triggers."),(0,r.kt)("p",null,"The example triggers utilise the ",(0,r.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/azure/data-factory/how-to-create-tumbling-window-trigger?tabs=data-factory"},"tumbling window trigger")," type. A tumbling window is a continuous and non-overlapping time interval. It allows reliable incremental data ingestion and, in Data Factory, allows re-running of specific windows later if an error happens and ensures that no data will be lost."),(0,r.kt)("p",null,"The trigger can be setup to any granularity down to 5 minutes. Every time it triggers a pipeline, it automatically passes the windowStart and windowEnd parameters for the relevant time window.\nIf any kind of incident happens, the missing or failed time windows will run retroactively as soon as possible, either sequentially or in parallel (following the Max concurrency option). The benefit of this behaviour it that it guaranties that no time windows are lost or forgotten even if ran days later. Data Factory allows us to re-run individual time windows at will, even if they succeeded."),(0,r.kt)("p",null,"Other types of Data Factory triggers are available, including schedule or event-based - these may be utilised dependent on your requirements."))}g.isMDXComponent=!0},5047:function(e,t,a){t.Z=a.p+"assets/images/ADF_IngestGenerateIngestQuery-875a13c99e0cd363046554d3c37182d0.png"},6050:function(e,t,a){t.Z=a.p+"assets/images/ADF_IngestPipelineDesign-1c61616f6fb3baa0101682c3e522412d.png"},2359:function(e,t,a){t.Z=a.p+"assets/images/ADF_IngestPipelinesList-e62d3f121f131951eb307ac286be4129.png"},9392:function(e,t,a){t.Z=a.p+"assets/images/ADF_Ingest_AzureSql_Example-66feb8518733339a00c4fa1aa4e0784b.png"}}]);